const supertest=require("supertest")
const {validateEmail,validateIPaddress}= require("./helpers")
const http=require("http")
const app=require("../index")
describe("ENDPOINT TESTING",()=>{
    jest.setTimeout(500000)    
    let server=http.createServer(app)
    let request;
    beforeAll((done)=>{
        server.listen(done)
        request=supertest(server)
    })
    afterAll((done) => {
        server.close(done);
      });   
    describe("GET",()=>{
        test("/",async ()=>{
            const response= await request.get("/")
            expect(response.status).toBe(200)
            expect(response.headers['content-type']).toBe("text/html; charset=utf-8")
            expect(response.text).toBe("HELLO WORLD")
        })      
        test("/ela",async ()=>{
            const response= await request.get("/ela")
            const data=JSON.parse(response.text)
            expect(response.status).toBe(200)
            expect(response.headers['content-type']).toBe("application/json; charset=utf-8")            
            expect(data).toBeInstanceOf(Object)   
            expect(data).toContainKeys(["isRunning","servicesRunning"])                                       
            expect(data.isRunning).toBeBoolean()
            expect(data.servicesRunning).toBeBoolean()            
        }) 
        test("/eid",async ()=>{
            const response= await request.get("/eid")
            const data=JSON.parse(response.text)
            expect(response.status).toBe(200)
            expect(response.headers['content-type']).toBe("application/json; charset=utf-8")   
            expect(data).toBeInstanceOf(Object)     
            expect(data).toContainKeys(["isRunning","servicesRunning"])                                                                                    
            expect(data.isRunning).toBeBoolean()
            expect(data.servicesRunning).toBeBoolean()            
        })
        test("/esc",async ()=>{
            const response= await request.get("/esc")
            const data=JSON.parse(response.text)
            expect(response.status).toBe(200)
            expect(response.headers['content-type']).toBe("application/json; charset=utf-8")                        
            expect(data).toBeInstanceOf(Object)           
            expect(data).toContainKeys(["isRunning","servicesRunning"])                                                                                                                   
            expect(data.isRunning).toBeBoolean()
            expect(data.servicesRunning).toBeBoolean()            
        })
        test("/feeds",async ()=>{
            const response= await request.get("/feeds")
            const data=JSON.parse(response.text)
            expect(response.status).toBe(200)
            expect(response.headers['content-type']).toBe("application/json; charset=utf-8")                        
            expect(data).toBeInstanceOf(Object)       
            expect(data).toContainKeys(["isRunning"]) 
            expect(data).toHaveProperty('isRunning')
            expect(data.isRunning).toBeBoolean()
        })        
        test("/carrier",async ()=>{
            const response= await request.get("/carrier")
            const data=JSON.parse(response.text)
            expect(response.status).toBe(200)
            expect(response.headers['content-type']).toBe("application/json; charset=utf-8")                        
            expect(data).toBeInstanceOf(Object)                                          
            expect(data).toContainKeys(["isRunning","carrierIP"])
            expect(validateIPaddress(data.carrierIP)).toBeTrue()                    
            expect(data.isRunning).toBeBoolean()
        })
        test("/downloadWallet",async ()=>{
            const response= await request.get("/downloadWallet")
            const data=response.body
            expect(response.status).toBe(200)
            expect(response.headers['content-type']).toBe("application/octet-stream")      
            expect(data).toBeInstanceOf(Buffer)                  

        })
        test("/checkInstallation",async ()=>{
            const response= await request.get("/checkInstallation")
            const data=JSON.parse(response.text)
            expect(response.status).toBe(200)
            expect(response.headers['content-type']).toBe("application/json; charset=utf-8")      
            expect(data).toBeInstanceOf(Object)       
            expect(data).toContainKeys(["configed"])            
            expect(data.configed).toBeOneOf(["true","false"])                    
        })
        test("/getOnion",async ()=>{
            const response= await request.get("/getOnion")
            const data=JSON.parse(response.text)  
            expect(response.status).toBe(200)
            expect(response.headers['content-type']).toBe("application/json; charset=utf-8")      
            expect(data).toBeInstanceOf(Object) 
            expect(data).toContainKeys(["onion"])               
            expect(data.onion).toContain(".onion")                     
        })
        test("/regenerateOnion",async ()=>{
            let response=await request.get("/getOnion")
            const oldData=JSON.parse(response.text)
            response= await request.get("/regenerateOnion")
            const newData=JSON.parse(response.text)  
            expect(response.status).toBe(200)
            expect(response.headers['content-type']).toBe("application/json; charset=utf-8")      
            expect(newData).toBeInstanceOf(Object) 
            expect(newData).toContainKeys(["onion"])                 
            expect(newData.onion).toContain(".onion")                     
            expect(newData.onion).not.toBe(oldData.onion)
        })
        test("/check_new_updates",async ()=>{
            const response= await request.get("/check_new_updates")
            const data=JSON.parse(response.text)  
            expect(response.status).toBe(200)
            expect(response.headers['content-type']).toBe("text/html; charset=utf-8")      
            expect(data).toBeInstanceOf(Object)    
            expect(data).toContainKeys(["count","current","latest","new_update"])
            expect(data.current).toBeNumber()
            expect(data.current).toBeNumber()
            expect(data.latest).toBeNumber() 
            expect(data.new_update).toBeBoolean()           
        })
        test("/download_package",async ()=>{
            response= await request.get('/download_package')
            const data=response.text          
            expect(response.status).toBeOneOf([200,500]) 
            expect(response.headers["content-type"]).toBe("text/html; charset=utf-8")       
            if(response.status === 200){
                expect(data).toBeBoolean()
                expect(data).toBe(true)
            }     
            else{
                expect(data).toBeString()                
                expect(data).toBe("Download error.")
            }
        })        
    })
    describe("POST",()=>{
        test("/getBalance",async ()=>{
            response= await request.post("/getBalance").send({address:"2091u3183213"})
            const data=JSON.parse(response.text)
            expect(response.status).toBe(200)            
            expect(response.headers["content-type"]).toBe("application/json; charset=utf-8")
            expect(data).toBeInstanceOf(Object) 
            expect(data).toContainKeys(["balance"])
            expect(data.balance).toBeString()
        })
        test("/restartMainchain",async ()=>{
            response= await request.post("/restartMainchain")         
            const data=JSON.parse(response.text)
            expect(response.status).toBe(200)            
            expect(response.headers["content-type"]).toBe("application/json; charset=utf-8")
            expect(data).toBeInstanceOf(Object) 
            expect(data).toContainKeys(["sucess"])
            expect(data.sucess).toBeBoolean()

        })
        test("/resyncMainchain",async ()=>{
            response= await request.post("/resyncMainchain")         
            const data=JSON.parse(response.text)      
            expect(response.status).toBe(200)            
            expect(response.headers["content-type"]).toBe("application/json; charset=utf-8")
            expect(data).toBeInstanceOf(Object) 
            expect(data).toContainKeys(["sucess"])
            expect(data.sucess).toBeBoolean()

        })
        test("/restartEID",async ()=>{
            response= await request.post("/restartEID")         
            const data=JSON.parse(response.text)      
            expect(response.status).toBe(200)            
            expect(response.headers["content-type"]).toBe("application/json; charset=utf-8")
            expect(data).toBeInstanceOf(Object) 
            expect(data).toContainKeys(["sucess"])
            expect(data.sucess).toBeBoolean()            
        })
        test("/resyncEID",async ()=>{
            response= await request.post("/resyncEID")         
            const data=JSON.parse(response.text)      
            expect(response.status).toBe(200)            
            expect(response.headers["content-type"]).toBe("application/json; charset=utf-8")
            expect(data).toBeInstanceOf(Object) 
            expect(data).toContainKeys(["sucess"])
            expect(data.sucess).toBeBoolean()                        
        })
        test("/restartESC",async ()=>{
            response= await request.post("/restartESC")         
            const data=JSON.parse(response.text)      
            expect(response.status).toBe(200)            
            expect(response.headers["content-type"]).toBe("application/json; charset=utf-8")
            expect(data).toBeInstanceOf(Object) 
            expect(data).toContainKeys(["sucess"])
            expect(data.sucess).toBeBoolean()                 
        })
        test("/resyncESC",async ()=>{
            response= await request.post("/resyncESC")         
            const data=JSON.parse(response.text)      
            expect(response.status).toBe(200)            
            expect(response.headers["content-type"]).toBe("application/json; charset=utf-8")
            expect(data).toBeInstanceOf(Object) 
            expect(data).toContainKeys(["sucess"])
            expect(data.sucess).toBeBoolean()                             
        })
        test("/restartCarrier",async ()=>{
            response= await request.post("/restartCarrier")         
            const data=JSON.parse(response.text)      
            expect(response.status).toBe(200)            
            expect(response.headers["content-type"]).toBe("application/json; charset=utf-8")
            expect(data).toBeInstanceOf(Object) 
            expect(data).toContainKeys(["sucess"])
            expect(data.sucess).toBeBoolean()                                         
        })
        // test("/restartFeeds",async ()=>{
        //     response= await request.post("/restartFeeds")         
        //     const data=JSON.parse(response.text)      
        //     expect(response.status).toBe(200)            
        //     expect(response.headers["content-type"]).toBe("application/json; charset=utf-8")
        //     expect(data).toBeInstanceOf(Object) 
        //     expect(data).toContainKeys(["success"])
        //     expect(data.success).toBeBoolean()                                         
        // })        
        test("/sendElaPassswordVerification",async ()=>{
            response= await request.post("/sendElaPassswordVerification").send({pwd:"testpass"})         
            const data=JSON.parse(response.text)          
            expect(response.status).toBe(200) 
            expect(response.headers["content-type"]).toBe("application/json; charset=utf-8")            
            expect(data).toBeInstanceOf(Object)
            expect(data).toContainAnyKeys(["ok","address"])
            expect(data.ok).toBeBoolean()
            if(data.address){
                expect(validateEmail(data.address)).toBeTrue()
            }

        })
        test("/sendTx",async ()=>{
            response= await request.post("/sendTx").send({pwd:"testpass",recipient:"",amount:0})         
            const data=JSON.parse(response.text)          
            expect(response.status).toBe(200) 
            expect(response.headers["content-type"]).toBe("application/json; charset=utf-8")  
            expect(data).toBeInstanceOf(Object)
            expect(data).toContainKeys(["ok"])
            expect(data.ok).toBeString()
            expect(data.ok).toBeOneOf(['ok',"nope"])          
        })
        test("/resyncNodeVerification",async ()=>{
            response= await request.post("/resyncNodeVerification").send({pwd:"testpass"})         
            const data=JSON.parse(response.text)          
            expect(response.status).toBe(200) 
            expect(response.headers["content-type"]).toBe("application/json; charset=utf-8") 
            expect(data).toBeInstanceOf(Object)
            expect(data).toContainAnyKeys(["ok","address"])
            expect(data.ok).toBeBoolean()
        })
        test("/login",async ()=>{
            response= await request.post("/login").send({pwd:"testpass"})         
            const data=JSON.parse(response.text)          
            expect(response.status).toBe(200) 
            expect(response.headers["content-type"]).toBe("application/json; charset=utf-8") 
            expect(data).toBeInstanceOf(Object)
            expect(data).toContainAnyKeys(["ok","address"])
            expect(data.ok).toBeBoolean()            
        })
        test("/createWallet",async ()=>{
            response= await request.post("/createWallet").send({pwd:"testpass"})         
            const data=JSON.parse(response.text)          
            expect(response.status).toBe(200) 
            expect(response.headers["content-type"]).toBe("application/json; charset=utf-8") 
            expect(data).toBeInstanceOf(Object)
            expect(data).toContainKeys(["ok"])
            expect(data.ok).toBeString()
            expect(data.ok).toBeOneOf(['ok',"nope"])
        })
        test("/version_info", async ()=>{
            response= await request.post("/version_info")   
            const data=JSON.parse(response.text)          
            expect(response.status).toBe(200) 
            expect(response.headers["content-type"]).toBe("application/json; charset=utf-8")             
            expect(data).toBeInstanceOf(Object)
            expect(data).toContainAnyKeys(["version","env"])
            expect(data.env).toBeString()            
            if(data.version){
                expect(data.version).toBeNumber()                
            }
        })
    })
})

